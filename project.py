import time


#in order to solve the puzzle, I first created the objects (board, node), then I created the functions that were used in the general template given by the professor in the slides.

#first, I will create a node class, which will contain the state (the location), and the parent node, also the cost and heuristic
class Node: 
    def __init__(self, state, parent, cost, heuristic):
        self.state = state
        self.parent= parent
        self.cost=cost
        self.heuristic = heuristic
  
# The Problem class will keep track of the initial state tied to the problem, and the goal state as well. 
#N is the size of the board. here I am setting the N to be 3, which is a 3x3 board; but that can be easily changed by changing N and the initial state.
class Problem: 
    def __init__( self, initial_state, goal_state, N): 
        self.initial_state = initial_state
        self.goal_state = goal_state
        self.N = N

    def goal_test(self,state):
        return state == self.goal_state 
    
N = 3 

#helper for the general search template
def make_queue(node):
    return [node]


#the goal state is generated by making a tuple using the N number, and ending with a 0 (where the blank tile would go)
# this way the goal solution wouldn't have to be hardcoded as well.

goal_state = tuple(list(range(1, N*N)) + [0])


def print_board(state, N):
    for i in range(N):
        for j in range(N):
            print(state[i*N + j], end=" ") 
        print()

# getcost will have quick access to the cost of each node, and will be used in the heuristic calculations
# . In UCS the heuristic isnt needed, so I only added the cost
def getcost(node):
    return node.cost 
#this function will calculate the f, which is f(n) = g(n)+h(n) (as seen in lecture)
def getf(node):
    return node.cost + node.heuristic   


#for this function, i need to implement the allowed movements, so moving up or down. and right and left
def operators(state, N):  #i am also keeping it general by using N instead of hardcoding the 3. That way the user only needs to change the N once.

    zero = state.index(0)
    row = zero // N 
    column = zero % N

    states = []

    if row > 0: #moving up (meaning theres more than 1 row)
        new_state = list(state)
        new_state[zero], new_state[zero-N] = new_state[zero-N], new_state[zero] #swapping the position of the tile with the blank tile 
        states.append(tuple(new_state))
    
    if row < N-1: #moving down 
        new_state = list(state)
        new_state[zero], new_state[zero+N] = new_state[zero+N], new_state[zero]
        states.append(tuple(new_state))

    if column > 0: #moving left 
        new_state= list(state)
        new_state[zero], new_state[zero-1] = new_state[zero-1], new_state[zero]
        states.append(tuple(new_state))
    
    if column < N-1: #moving right 
        new_state = list(state)
        new_state[zero], new_state[zero+1] = new_state[zero+1], new_state[zero]
        states.append(tuple(new_state))

    return states


# to remove the front in python I can just pop(0)

def remove_front(queue):
    if  queue:
        return queue.pop(0)
    if not queue:
        return "empty"
    
def expand(node, problem):
    expanded  = []
    possible_moves = operators(node.state,problem.N)
    for move in possible_moves:
        new_node = Node(move,node, node.cost +1 ,0)
        expanded.append(new_node)
    return expanded




#done.
def solution(node):
    solutions = []
    while node is not None:
        solutions.append(node) 
        node = node.parent
    solutions.reverse()
    #print("maximum queue size was", len(solutions)) 
    return solutions


def general_search(problem, queuing_function):
    nodes = make_queue(Node(problem.initial_state, None, 0, 0))
    visited = set()
    node_counter =0 
    max_queue =0 
    start_timer = time.time()
    while True:

        current_total = len(nodes) + len(visited) #this was taught to me by TA Michael Collins
        if current_total > max_queue:
            max_queue = current_total

        if not nodes:
            return "failure"
        node = remove_front(nodes)
        if problem.goal_test(node.state):
            end_timer = time.time()
            timer_count = end_timer- start_timer
            print(f"nodes expanded was {node_counter}")
            print(f"max queue size was {max_queue}")
            print(f"time taken was {timer_count:.4f} seconds")
            return solution(node)
        #nodes = queuing_function(nodes, expand(node, problem))
        if node.state not in visited:
            node_counter = node_counter +1
            visited.add(node.state) 
            nodes = queuing_function(nodes, expand(node, problem))
           # print(f"debug : max queue size was {max_queue}")
            #print(f"debug :nodes expanded was {node_counter}")
        
            
def uniform_cost_search(nodes, new_nodes):
    nodes.extend(new_nodes)
    nodes.sort(key = getcost)
    return nodes

# now i need to work on making the A* using the Manhattan Search and the misplaced tile heuristic


#for manhattan, we need to calculate the distance between the current node from the goal state
def heuristics_manhattan(state, goal_state, N):
    distance = 0
    for i in range(len(state)):
        if state[i] != 0:
            row = i//N 
            column = i %N
            goal = goal_state.index(state[i])
            goal_row = goal //N 
            goal_column = goal% N

            distance = distance + abs(row - goal_row)+abs(column- goal_column)
    return distance

def manhattan_distance(nodes, new_nodes):
    for node in new_nodes:
        node.heuristic= heuristics_manhattan(node.state, goal_state, N)
    nodes.extend(new_nodes)
    nodes.sort(key = getf)
    return nodes

    


#misplaced tile just counts the amount of tiles that are in the wrong place

def heuristics_misplaced(state, goal_state):
    misplaced = 0 
    for i in range(len(state)):
        if state[i] != 0 and state[i] != goal_state[i]:
            misplaced =misplaced +1 
    return misplaced


def misplaced_tile(nodes, new_nodes):
    for node in new_nodes:
        node.heuristic= heuristics_misplaced(node.state, goal_state)
    nodes.extend(new_nodes)
    nodes.sort(key = getf)
    return nodes
            




N = 3




print("Enter the board row by row")
board_start = tuple(map(int, input("> ").split()))
#board_start = (1, 2, 3, 4, 5, 6, 0, 7, 8) update: will ask user for input instead
my_problem = Problem(board_start, goal_state, N)


print("Starting Manhattan Distance")
result_path = general_search(my_problem, manhattan_distance)
if result_path == "failure":
    print("No solution found!")
else:
    print(f"Solved in {len(result_path) - 1} moves.")
    print("-" * 20)
    for step, node in enumerate(result_path):
        print(f"Step {step} (Cost: {node.cost}):")
        print_board(node.state, N)
        print()




#/* once i am done making the functions and creating the board, I will adapt the function
#to the heuristics given and the algorithms. Then, I will tie it all together 

#tomorrow 02.05:
#- adapt the search algorithms using skeleton
#- finish setting up the game board 
#- implement the heuristics, and tie it all together.
#*/